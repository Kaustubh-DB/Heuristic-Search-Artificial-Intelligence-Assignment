# Assignment 1 - Searching
# Part 1 : The Luddy Puzzle

#### Formulation:
The game board consists of 4 * 4 grid with 15 tiles numbered from 0
to 15 in a randomized way. In each turn, the player can slide a tile into an adjacent empty space. Our job is to find a set of sliding moves of the blank tile which converts the initial board to the goal state.
## Abstraction

#### Intitial State:
Random arrangement of tiles from 0-15, 0 numbered tile being a blank tile

#### Goal State:
Tiles arranged in an ascending order from 1-15  with 0 at the last position of the grid.

#### State Space:
State of all objects are stored in the fringe. Each state object contains, the heuristic value of that node and an evaluation value i.e g(s) + h(s),  the path to the current state from the initial node.

#### Successor function
Successor function will give us the next possible states that can be generated by moving the blank tile. In this assignment, we have 3 Successor functions depending on the variant the users passes as an input
1. Original: This Successor function generates successors of its neighboring tiles in all the direction of the current state, Up, down , left, bottom. We use check valid-index method to determine whether node exists specially in the case of edge nodes.
2. Circular: In this variant, the successor function is defined same as original variant considering circular moves constraint.
3. Luddy: Defined 8 moves with respect to the luddy constraint and successor can be found based on this moves.

#### Heuristic Function:
This heuristic function returns the number of misplaced tiles of current state. That is, it checks every tile of every game board to see if it is in goal-state. We first move the empty tile in all possible direction in the current state and calculate the h-score which is nothing but number of misplaced tiles. Then g-score is evaluated as number of nodes traversed from the start state to the current state. Example

#### Admissibility of the heuristic:
We can say that the heuristic function is admissible because we are always underestimating the cost to reach the goal state, i.e. we cannot reach the goal state in fewer number of moves than the number of misplaced tiles in the board. Hence, each tile which is not in place must be moved at least once, this shows the admissibility.

#### Algorithm Used
The code was implemented using A* algorithm (Search 3 Algorithm)

#### Code Flow
The code takes two inputs one is board and other the variant. Then the code takes the initial-board as its first state as a start stage and finds the empty tile that is tile numbered 0. Depending on the variant the start state calculates all of its successor. Once the successors are calculated, it is added it to the closed set. Then for every successor we calculate the heuristic function and adds it to the priority queue. The node having the least heuristic value is returned or popped out of the queue. This process is repeated until we get the final state.

#### Approach & Problem Faced

The given code snippet was working only for original variant. Our next task was to make it work for two new variants circular and luddy respectively. Original variant was not giving a best solution as it did not take into account the visited state because of this some boards were running into an infinite loop.

We first of all implemented the visited state logic to remove the states that were already visited and then thought of implementing heuristic. There was some confusion in choosing heuristic, so this link quite helped me. https://cs.stackexchange.com/questions/37795/why-is-manhattan-distance-a-better-heuristic-for-15-puzzle-than-number-of-til

Pseudo Code for Heuristic: Number of Misplaced Tiles.

for i in the state:

if state[i] is not equal to i+1  
#this will ensure all the nodes are in ascending order

increment count
return count
#count will only increment if the two adjacent tiles are not in the ascending order

The next step was to implement priority queue to get the least value of the heuristic. Some state space was quite huge because of which our A* algorithm was not fast enough and consumed lots of time. To handle this case, I first of all thought may be using different heuristic could solve my problem at ease or perhaps it is due to heuristic I am getting large number of state space and traversing in the same loop. I tried using manhattan distance heuristic but was in the same loop hole of infinite loop and timeout error. Also read about IDA * search algorithm as it is the fastest solution to get the output. I tried implementing IDA * search but because the implementation was too complicated was not able to do so.

# Part 2 - Road trip!

### I) a description of how you formulated the search problem, including precisely defning the state space, the successor function, the edge weights, the goal state, and (if applicable) the heuristic function(s) you designed, including an argument for why they are admissible;

Formulation: The user will give a to and from city for which we have to find a route which will be optimal according to the constraint given by the user.
1.Initial State: All the segment containing start city
2.Goal State: The Current hop made has the End city (Example: if my end city is B and my current hop is B to C then its my                    goal state) 
3.Successor Function and edge weight and heuristic: According to the constraint the cost of every succesor is returned
-distance - haversine distance for next city in the hop and destination i.e the end_city is calculated and added to the         existing cost
-segments - for every hop segment++
-time - distance given in the data divided by speed limit given in the data i.e the road-segments.txt and added to the          existing cost
-mpg - calculated using the formula in the Instructions for "V" in the formula used the speed limit for that hop and added      to the existing cost
4.Admissibality: As we are haversine distance it will always give optimal solution 

### II) a brief description of how your search algorithm works
List of Functions and Code Flow
1. Main function
-we take command line arguments in variables
-we check if the given constraint is correct and the given cities name are in the data set
-call parse_document function
-call A star function
2. parse_document()
-parse road-segments.txt in gv_rd_seg_lst list structure
-parse city-gps.txt in gv_cty_gps_lst list structure
4. Using haversine function of Python directly
-to calculate the GPS distance between two location which will be used in
A* search heuristic for distance constraint
5. dist_calc()
-it passes values to haversine_distance()
-the values are extracted from gv_cty_gps_lst - latitude and longitude of current and destination city
6. cost_calc()
-for every next hop possible we need to calculate cost of that hop which is done in this function
7. a_star_srch()
-we chack if initial state is same as goal state or not
-if not we initialize a priority queue
we use priority queue and the priority queue uses the cost to pop the next segment with lowest cost calculated in cost_clac
-Queue is initialized with the initial segments based on start city
-the while loop runs till queue is empty in this case printing "INF" or till we reach goal state
-we pop the value with the lowest cost an duse it as the current state
-successors for this current state are calculated if the current state is not equal to goal state
-for every successor we calculate the next cost, distance, time, total gas gallon, segments
-we append the route as well over here for every successor
-when the goal state is found we print the segment, distance travelled, time required, total gas gallons, and path

### III)discussion of any problems you faced, any assumptions,simplications, and/or design decisions.
1.initially both files were parsed in list structure for time optimization it was changed to dictionary after comparison of      run time list structure took less time
2.bidirectional case handling : we switched the city names  where needed in the successor states
Cities which didn't have GPS details case handling : in dist_calc() if we do not find details in the given data we return 0.
if the returned value from dist_calc is 0 we consider the distance                                        given for that segment in the dataset
3.the haversine module is not available on SICE server - added a function for it haversine_distance()
4.For mpg "V" in the formula given assumed the speed limit for that hop
5.total gas gallons = (hop distance/mpg for the hop) 


# Part 3 - Choosing a team

## Proble Statement 
Choose a team of robots that has the greatest possible skill

## Given Code :  
The sceleton code used a greedy approach to choose the team of robots. Firstly the list of robots is picked in decreasing order of skill per unit cost. But the solution was not giving the team of robots in whole number.
So to give the solution in more optimized way we reversed the robots in the sorted list and removed the logic for fraction solution in the Else part of If Statement. This gave me the answer for the team of robots in whole number(1.0000).

```
def approx_solve(people, budget): 

This function solves the code using Greedy Search
Which may or may not be optimal for every scenario
```
## Problem Faced : 
We tried using multiple datasets for the above approch but the code didn't gave the optimal solution for all the case. This was because the code considers the perfect solution is the one that it finds at that moment. 

To solve this we thought of using the Knapsack algorithm which is similar used to solve similar problems as the problem statement. 

Then we started implementing the 0/1 Knapsack problem with the Dynamic programming approach. Though if using the matrix technique approach for calculating the max cost and perfect team of robots. But as the values for cost and skills were in the floating point we used naive way of taking the round of that number and solving it. But this didn't gave the optimal solution for the robots who were having cost/skill relatively similar values. 

## Final Approach :  
```
Knapsack Branch and Bound Function 

def approx_solve_branchandbound(people, budget):
```
1) Algorith Used : 0/1 Knapsack using Branch and Bound 
        As the problem statement is based on solving combinatory optimization 0/1 knapsack algorithm provides optimized solution for choosing robots based on the budget given. 
        This algorithm solved both the problems faced in 2 earlier approaches and gave the optimum solution for every single dataset and case. The backtracking solution helps in ignoring the infeasible solutions.

2) Flow : 
    Created 2 classes for storing the Robots details and Robots State in the node of tree
    Code starts with reading the file and storing the data in the dictionary.
    Sorted all the robot items in the descending order of ratio of cost per skills
    Initialize the max_skill =0 and also Added a dummy node of Decision tree and added it to Dequeue.
    After that untill the deque is not empty we deque one by one element and find profit of next node. If the profit is more then we update the max_skill. Then calculate Upper Bound and if bound > max_skill then add node to the dequeue.
    Consider the case when next node is not considered but we have to add the next level to the dequeue without updating the max_skill.
```
Class to calculate the upper bound for element

def calculate_bound(u, capacity, item_count, items):
```
